(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{145:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return b}));var a=n(2),o=n(9),i=(n(0),n(154)),c={id:"auto-recovery",title:"Automatic Recovery From Network Failures",sidebar_label:"Automatic Recovery"},r={id:"auto-recovery",isDocsHomePage:!1,title:"Automatic Recovery From Network Failures",description:"A network connection between clients and ActiveMQ Artemis nodes can fail. The client library supports the automatic recovery of connections, producers, and consumers. Automatic recovery is enabled by default.",source:"@site/../docs/auto-recovery.md",permalink:"/dotnet-activemq-artemis-client/docs/auto-recovery",editUrl:"https://github.com/Havret/dotnet-activemq-artemis-client/edit/master/website/../docs/auto-recovery.md",sidebar_label:"Automatic Recovery",sidebar:"someSidebar",previous:{title:"Message Priority",permalink:"/dotnet-activemq-artemis-client/docs/message-priority"}},l=[{value:"Recovery Policies",id:"recovery-policies",children:[{value:"Constant Backoff Recovery Policy",id:"constant-backoff-recovery-policy",children:[]},{value:"Linear Backoff Recovery Policy",id:"linear-backoff-recovery-policy",children:[]},{value:"Exponential Backoff Recovery Policy",id:"exponential-backoff-recovery-policy",children:[]}]},{value:"Recover from first failure fast",id:"recover-from-first-failure-fast",children:[]},{value:"Disabling Automatic Recovery",id:"disabling-automatic-recovery",children:[]},{value:"Failover",id:"failover",children:[]}],s={rightToc:l};function b(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"A network connection between clients and ActiveMQ Artemis nodes can fail. The client library supports the automatic recovery of connections, producers, and consumers. Automatic recovery is enabled by default."),Object(i.b)("p",null,"Automatic recovery is controlled by ",Object(i.b)("inlineCode",{parentName:"p"},"IRecoveryPolicy")," interface:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"public interface IRecoveryPolicy\n{\n    int RetryCount { get; }\n    TimeSpan GetDelay(int attempt);\n}\n")),Object(i.b)("p",null,"This interface defines how long the delay should be between subsequent recovery attempts if recovery fails due to an exception (e.g. ActiveMQ Artemis node is still not reachable), and how many recovery attempts will be made before terminal exception will be signaled."),Object(i.b)("p",null,"You can subscribe to this occurrence using ",Object(i.b)("inlineCode",{parentName:"p"},"IConnection.ConnectionRecoveryError")," event:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"var connectionFactory = new ConnectionFactory();\nvar connection = await connectionFactory.CreateAsync(endpoint);\nconnection.ConnectionRecoveryError += (sender, eventArgs) =>\n{\n    // react accordingly\n};\n")),Object(i.b)("p",null,"When the client library successfully reestablishes the connection, ",Object(i.b)("inlineCode",{parentName:"p"},"IConnection.ConnectionRecovered")," event is triggered instead."),Object(i.b)("p",null,"To retry indefinite amount of times ",Object(i.b)("inlineCode",{parentName:"p"},"RetryCount")," should return ",Object(i.b)("inlineCode",{parentName:"p"},"int.MaxValue"),"."),Object(i.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})))),"tip")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"If the initial connection to an ActiveMQ Artemis node fails, automatic connection recovery will kick in as well. It may be problematic in some scenarios, as ",Object(i.b)("inlineCode",{parentName:"p"},"ConnectionFactory.CreateAsync")," won't signal any issues until the recovery policy gives up. If your recovery policy is configured to try to recover forever it may even never happen. That means you would be asynchronously waiting for the result of ",Object(i.b)("inlineCode",{parentName:"p"},"CreateAsync")," forever. To address this issue you can pass ",Object(i.b)("inlineCode",{parentName:"p"},"CancellationToken")," to ",Object(i.b)("inlineCode",{parentName:"p"},"CreateAsync"),". This allows you to arbitrarily break the operation at any point."))),Object(i.b)("h2",{id:"recovery-policies"},"Recovery Policies"),Object(i.b)("p",null,"There are 3 built-in recovery policies that are available via ",Object(i.b)("inlineCode",{parentName:"p"},"RecoveryPolicyFactory")," class:"),Object(i.b)("h3",{id:"constant-backoff-recovery-policy"},"Constant Backoff Recovery Policy"),Object(i.b)("p",null,"This policy instructs the connection recovery mechanism to wait a constant amount of time between recovery attempts."),Object(i.b)("p",null,"The following defines a policy that will retry 5 times and wait 1s between each recovery attempt."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"var constantBackoff = RecoveryPolicyFactory.ConstantBackoff(\n    delay: TimeSpan.FromSeconds(1),\n    retryCount: 5);\n")),Object(i.b)("h3",{id:"linear-backoff-recovery-policy"},"Linear Backoff Recovery Policy"),Object(i.b)("p",null,"This policy instructs the connection recovery mechanism to wait increasingly longer times between recovery attempts."),Object(i.b)("p",null,"The following defines a policy with a linear retry delay of 100, 200, 300, 400, 500ms."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"var linearBackoff = RecoveryPolicyFactory.LinearBackoff(\n    initialDelay: TimeSpan.FromMilliseconds(100),\n    retryCount: 5);\n")),Object(i.b)("p",null,"The default linear factor is 1.0. However, it can be changed:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"var linearBackoff = RecoveryPolicyFactory.LinearBackoff(\n    initialDelay: TimeSpan.FromMilliseconds(100),\n    retryCount: 5,\n    factor: 2);\n")),Object(i.b)("p",null,"This will create an increasing retry delay of 100, 300, 500, 700, 900ms."),Object(i.b)("p",null,"Note, the linear factor must be greater than or equal to zero. A factor of zero will return equivalent retry delays to the ",Object(i.b)("inlineCode",{parentName:"p"},"ConstantBackoffRecoveryPolicy"),"."),Object(i.b)("p",null,"When the infinite number of retires is used, it may be useful to specify a maximum delay:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"var linearBackoff = RecoveryPolicyFactory.LinearBackoff(\n    initialDelay: TimeSpan.FromMilliseconds(100),\n    maxDelay: TimeSpan.FromSeconds(15));\n")),Object(i.b)("h3",{id:"exponential-backoff-recovery-policy"},"Exponential Backoff Recovery Policy"),Object(i.b)("p",null,"This policy instructs the connection recovery mechanism to use the exponential function to calculate subsequent delays between recovery attempts. The delay duration is specified as ",Object(i.b)("inlineCode",{parentName:"p"},"initialDelay x 2^attempt"),". Because of the exponential nature (potential for rapidly increasing delay times), it is recommended to use this policy with a low starting delay, and explicitly setting maximum delay."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"var exponentialBackoff = RecoveryPolicyFactory.ExponentialBackoff(\n    initialDelay: TimeSpan.FromMilliseconds(100),\n    retryCount: 5);\n")),Object(i.b)("p",null,"This will create an exponentially increasing retry delay of 100, 200, 400, 800, 1600ms."),Object(i.b)("p",null,"The default exponential growth factor is 2.0. However, you can provide our own."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"var exponentialBackoff = RecoveryPolicyFactory.ExponentialBackoff(\n    initialDelay: TimeSpan.FromMilliseconds(100),\n    retryCount: 5,\n    factor: 4.0);\n")),Object(i.b)("p",null,"The upper for this retry with a growth factor of four is 25,600ms."),Object(i.b)("p",null,"Note, the growth factor must be greater than or equal to one. A factor of one will return equivalent retry delays to the ",Object(i.b)("inlineCode",{parentName:"p"},"ConstantBackoffRecoveryPolicy"),"."),Object(i.b)("h2",{id:"recover-from-first-failure-fast"},"Recover from first failure fast"),Object(i.b)("p",null,"All build-in recovery policies include an option to recover after the first failure immediately. You can enable this by passing in ",Object(i.b)("inlineCode",{parentName:"p"},"fastFirst: true")," to any of the policy factory methods."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"var recoveryPolicy = RecoveryPolicyFactory.ExponentialBackoff(\n    initialDelay: TimeSpan.FromMilliseconds(100),\n    retryCount: 5,\n    factor: 4.0,\n    fastFirst: true);\n")),Object(i.b)("p",null,"Note, the first recovery attempt will happen immediately and it will count against your retry count. That is, this will still try to recover five times but the first recovery attempt will happen immediately after connection to the broker is lost."),Object(i.b)("p",null,"The logic behind a fast first recovery strategy is that failure may just have been a transient blip rather than reflecting a deeper underlying issue that for instance results in a broker failover."),Object(i.b)("h2",{id:"disabling-automatic-recovery"},"Disabling Automatic Recovery"),Object(i.b)("p",null,"To disable automatic recovery, set ",Object(i.b)("inlineCode",{parentName:"p"},"ConnectionFactory.AutomaticRecoveryEnabled")," to false:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"var connectionFactory = new ConnectionFactory();\nconnectionFactory.AutomaticRecoveryEnabled = false;\n// connection that will not recover automatically\n\nvar connection = await connectionFactory.CreateAsync(endpoint);\n")),Object(i.b)("h2",{id:"failover"},"Failover"),Object(i.b)("p",null,"To provide high availability your typical ActiveMQ Artemis cluster configuration should contain at least 2 nodes: a master and a slave. For most of the time, only the master node is operational and it handles all of the requests. When the master goes down, however, failover occurs and the slave node becomes active."),Object(i.b)("p",null,"To handle this scenario with the client library you need to use ",Object(i.b)("inlineCode",{parentName:"p"},"ConnectionFactory.CreateAsync")," overload that accepts ",Object(i.b)("inlineCode",{parentName:"p"},"IEnumerable<Endpoint>"),". This way when the connection to the first node is lost, the auto-recovery mechanism will try to reconnect to the second node. The endpoints are selected in a round-robin fashion using the original sequence with which the connection was created."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'var masterEndpoint = Endpoint.Create(\n    host: "master",\n    port: 5672,\n    user: "guest",\n    password: "guest",\n    scheme: Scheme.Amqp);\nvar slaveEndpoint = Endpoint.Create(\n    host: "slave",\n    port: 5672,\n    user: "guest",\n    password: "guest",\n    scheme: Scheme.Amqp);\nvar connectionFactory = new ConnectionFactory();\nvar connection = await connectionFactory.CreateAsync(new[]\n{\n    masterEndpoint,\n    slaveEndpoint\n});\n')))}b.isMDXComponent=!0}}]);